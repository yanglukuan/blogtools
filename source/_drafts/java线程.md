---
title: java线程
tags:
---


### 注重并发执行 提升效率

摩尔定律

充分利用多处理器（多核心）  多任务处理 减少cpu空闲等待 提高cpu利用率

每秒事务处理数（Transactions Per Second,TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数。


### 内存模型

物理计算机 计算机运算速度和存储速度差距较大，新增高速缓存在cpu和内存之间同步数据，遵循某种同步协议。

java虚拟机 
内存模型  jmm 屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。定义内存数据的访问和写入规则，主要是实例变量和静态变量，不包含局部变量，局部变量为线程私有，不会被共享。
主内存
工作内存


线程通信
内存共享、消息


内存模型围绕着在并发环境中处理可见性、原子性、有序性的特征。

volatile 只能保证可见性，禁止指令重排序。被volatile修饰的变量对其他线程总是可见的，不能保证原子性。如果操作为非原子操作，则依然是非线程安全的，例如a++。指令重排序会干扰程序的并发执行。
volatile适用于以下情况。
1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。
2、变量不需要与其他的状态变量共同参与不变约束。

synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。synchronized可以同时保证可见性、原子性和有序性。


遵循先行发生原则，时间先后顺序与先行发生原则之间基本没有太大的关系，所以我们衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。

程序次序规则（Program Order Rule）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
线程启动规则（Thread Start Rule）：Thread对象的start（）方法先行发生于此线程的每一个动作。
线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join（）方法结束、Thread.isAlive（）的返回值等手段检测到线程已经终止执行。
线程中断规则（Thread Interruption Rule）：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted（）方法检测到是否有中断发生。
对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize（）方法的开始。
传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。


线程模型
1：1
1：n
n：m

###  锁


### 并发包


### 线程安全


### 线程池
常用线程池






