---
title: HashMap详解
date: 2017-08-30 13:21:13
tags: [HashMap,集合]
categories: java
---

## 基础扫盲

### java 集合框架
Java集合工具包位于Java.util包下，包含了很多常用的数据结构，如数组、链表、栈、队列、集合、哈希表等。集合类主要分为两大类：Collection和Map。
**Collection**是List、Set等集合高度抽象出来的接口，它包含了这些集合的基本操作，它主要又分为三部分：List、Set和Queue。
**Map**是一个映射接口，其中的每个元素都是一个key-value键值对，同样抽象类AbstractMap通过适配器模式实现了Map接口中的大部分函数，TreeMap、HashMap、WeakHashMap等实现类都通过继承AbstractMap来实现，另外，不常用的HashTable直接实现了Map接口，它和Vector都是JDK1.0就引入的集合类。

<center>![Map接口类图](/images/javacollections.png)</center><center>***Map接口类图***</center>

### Hash 知识
维基百科的定义
>散列（英语：Hashing）是电脑科学中一种对资料的处理方法，通过某种特定的函数/算法（称为散列函数/算法）将要检索的项与用来检索的索引（称为散列，或者散列值）关联起来，生成一种便于搜索的数据结构（称为散列表）。也译为散列。旧译哈希（误以为是人名而采用了音译）。它也常用作一种资讯安全的实作方法，由一串资料中经过散列算法（Hashing algorithms）计算出来的资料指纹（data fingerprint），经常用来识别档案与资料是否有被窜改，以保证档案与资料确实是由原创者所提供。


### Hash 函数  
>散列函数（或散列算法，又称哈希函数，英语：Hash Function）是一种从任何一种数据中创建小的数字“指纹”的方法。散列函数把消息或数据压缩成摘要，使得数据量变小，将数据的格式固定下来。该函数将数据打乱混合，重新创建一个叫做散列值（hash values，hash codes，hash sums，或hashes）的指纹。散列值通常用一个短的随机字母和数字组成的字符串来代表。好的散列函数在输入域中很少出现散列冲突。在散列表和数据处理中，不抑制冲突来区别数据，会使得数据库记录更难找到。

上面是维基百科给出的定义，通俗点来讲，一般情况下，需要在关键字与它在表中的存储位置之间建立一个函数关系，以f(key)作为关键字为key的记录在表中的位置，通常称这个函数f(key)为哈希函数。

### 哈希表和查找
散列表是散列函数的一个主要应用，使用散列表能够快速的按照关键字查找数据记录。（注意：关键字不是像在加密中所使用的那样是秘密的，但它们都是用来“解锁”或者访问数据的。）例如，在英语字典中的关键字是英文单词，和它们相关的记录包含这些单词的定义。在这种情况下，散列函数必须把按照字母顺序排列的字符串映射到为散列表的内部数组所创建的索引上。哈希表是一个在时间和空间上做出权衡的经典例子,在没有碰撞的情况下，时间复杂度为O(1)。

### Hash 碰撞
对不同的关键字可能得到同一散列地址，即 {\displaystyle k_{1}\neq k_{2}} k_{1}\neq k_{2}，而 {\displaystyle f(k_{1})=f(k_{2})} f(k_{1})=f(k_{2})，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数 {\displaystyle f(k)} f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。解决碰撞有很多方法可以使用，最常用的包括链地址法和开地址法。HashMap就是用的链地址的方法解决冲突。

## HashMap
HashMap是我们经常使用一个映射容器，通过牺牲存储空间来换取检索时间，HashMap是采用了hash表数据结构思想来实现。在key未发生冲突的情况下，搜索时间复杂度为O(1),可以快速定位元素。因此在日常开发中也被程序员广泛使用，例如作为关系映射容器、简单缓存、提高检索速度等。HashMap最多只允许一个键值为null(保存在数据列表中的第0个元素的链表上)，允许value为null值。

### 存储结构
HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现。java的HashMap结构上采用了数组链表方式，即数组+链表的数据结构，采用这种结构的原因是采用了链地址的方法解决哈希冲突。但是这样带来了一个问题，当某个链表达到一定的长度时，对于链表元素的查找会变成线下搜索，比较耗时。所以在JDK1.8的实现中做了优化，当链表的长度达到一定数量（TREEIFY_THRESHOLD默认值为8）时，会把链表转为红黑树，所以在JDK1.8的版本HashMap的数据结构为数组+链表+红黑树。
在HashMap中，通过Node[] table，(1.7叫做Entry，1.8加入红黑树后改为Node,兼容红黑树的TreeNode)来实现该结构，该数组可以看做是一个哈希桶数组，每个桶中存放着一个链表，Node是链表节点,并实现了Map.Entry。Node节点存放一个键值对，同时存放一个指向下一个节点的引用。

### 存取 源码
1.几个重要的属性
int threshold; // 所能容纳的key-value对极限
final float loadFactor; // 负载因子
int modCount; // 修改次数
int size; // 元素数量

2.分析源码 存取过程

### 非线程安全并发问题

###  1.7和1.8实现区别

## 参考

http://zhengjianglong.leanote.com/post/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86HashMap
http://blog.csdn.net/qq_27093465/article/details/52209789
http://blog.csdn.net/qq_27093465/article/details/52207152
http://www.importnew.com/16599.html
http://www.nowamagic.net/academy/detail/3008010
